# -*- coding: utf-8 -*-
"""MOVIE_RATING PREDICTION.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BkoAUefQ7JSI8a8qCYcijam4YP4t8NPD

# CODSOFT INTERNSHIP


  TASK -1 : MOVIE RATING PREDICTION



 AUTHOR: VISHAL KUMAR
 DOMAIN : DATA SCIENCE
 BATCH : JULY-15

# **Import libraries for data processing and modelling**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

from google.colab import files
uploaded = files.upload()

"""**Linking dataset into colab**"""

import io
Movie=pd.read_csv((io.BytesIO(uploaded['IMDb Movies India (3).csv'])),encoding='unicode_escape')

"""Dataset first look"""

Movie.head(10)

Movie.shape

"""# **Data cleaning**"""

Movie.isnull().sum()

Movie.info()

Movie.duplicated().sum()

Movie.dropna(inplace=True)

Movie.isnull().sum()

Movie.drop_duplicates(inplace=True)

Movie.shape

Movie.columns

"""# **Data Pre-Processing**



*   Data have to be processed to make more easier to derive insights from it and pre-processed will be more suitable while fitting th data
*   The data is processed by column wise based on requirement


"""

# Replacing the brackets from year column
Movie['Year']= Movie['Year'].str.replace(r'[()]','',regex=True).astype(int)

# Removing the min word from 'Duration' and covert it into numeric
Movie['Duration']=pd.to_numeric(Movie['Duration'].str.replace(' min',''))

# splitting the genre by,to keep only unique genre and replacing the null value with mode
Movie['Genre']=Movie['Genre'].str.split(', ')
Movie=Movie.explode('Genre')
Movie['Genre'].fillna(Movie['Genre'].mode()[0],inplace=True)

#convert 'Votes' to numeric and replace this the, to keep only numerical part
Movie['Votes']=pd.to_numeric(Movie['Votes'].str.replace(',',''))

# Checking dataset for any null values present and data type of features
Movie.info()

"""# **Data Visualizing**



*  ->   Visualization part is done to show the relationship between the features present in the dataset
->   Multiple charts are used to see the relation withtin components of data which involved in the result.






"""

year=px.histogram(Movie,x='Year',histnorm='probability density',nbins=30)
year.show()

# Group data by year and calculate the average rating
avg_rating_by_year = Movie.groupby(['Year','Genre'])['Rating'].mean().reset_index()

#Get the top 10 genres
top_genres=Movie['Genre'].value_counts().head(10).index

# Filter the data to include only the top 3 genres
top_genres_data=avg_rating_by_year[avg_rating_by_year['Genre'].isin(top_genres)]

# Create the line plot with ploty Express
fig=px.line(avg_rating_by_year,x='Year',y='Rating',color="Genre")

# Set the title and axis labels
fig.update_layout(title='Average Rating by Year and Genre',xaxis_title='Year',yaxis_title='Average Rating')

# Show the plot
fig.show()

#This histogram shows the distribution of ratings and its density
rating_fig=px.histogram(Movie,x='Rating',histnorm='probability density',nbins=40)
rating_fig.update_layout(title='Distribution of Ratings',title_pad=dict(t=20),title_font=dict(size=20),xaxis_title='Rating',yaxis_title='probabilty density')
rating_fig.show()

"""# **Feature Engineering**"""

#Importing essential libraries for modeling building
from sklearn.model_selection import train_test_split,cross_val_score
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error,r2_score,mean_absolute_error,accuracy_score

#Droppong Name of column because it doesnot impact the outcome
Movie.drop('Name',axis=1,inplace=True)

#Grouping the columns with their average rating and then creating a new feature
genre_mean_rating=Movie.groupby('Genre')['Rating'].transform('mean')
Movie['Genre_mean_rating']=genre_mean_rating

director_mean_rating=Movie.groupby('Director')['Rating'].transform('mean')
Movie['Director_mean_rating']=director_mean_rating

actor1_mean_rating=Movie.groupby('Actor 1')['Rating'].transform('mean')
Movie['Actor1_encoded']=actor1_mean_rating

actor2_mean_rating=Movie.groupby('Actor 2')['Rating'].transform('mean')
Movie['Actor2_encoded']=actor2_mean_rating

actor3_mean_rating=Movie.groupby('Actor 3')['Rating'].transform('mean')
Movie['Actor3_encoded']=actor3_mean_rating

# keeping  the predict and target variable
X=Movie[['Year','Duration','Genre_mean_rating','Director_mean_rating','Actor1_encoded','Actor2_encoded','Actor3_encoded']]
y=Movie['Rating']

# Splitting the dataset into training and testing parts
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.2,random_state=42)

"""# **Model Building**"""

# Building machine learning model and training them
model=LinearRegression()
model.fit(X_train,y_train)
model_pred=model.predict(X_test)

# Evaluating the performance of model with evaluation matrics
print('The performance evaluation of logistic Regression is below : ', '\n')
print('Mean Absolute Error : ',mean_absolute_error(y_test,model_pred))
print('Mean Squared Error : ',mean_squared_error(y_test,model_pred))
print('R2 score : ',r2_score(y_test,model_pred))

"""# **Model Testing**"""

X.head(5)

y.head(5)

#for testing ,we create a new dataframe with values close to any of our existing data to evalute
data={ 'Year':[2019], 'Duration':[109],'Genre_mean_rating':[6.0],'Director_mean_rating':[7],'Actor1_encoded':[6.8],'Actor2_encoded' : [7],'Actor3_encoded' :[7] }
trail=pd.DataFrame(data)

# Predict the movie rating by entered data
rating_predicted =model.predict(trail)
# Display the predicted result from the model
print("Predicted Rating:",rating_predicted[0])